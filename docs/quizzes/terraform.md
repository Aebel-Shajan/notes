# Quiz: Terraform

<quiz>
Terraform's configuration language is called [[HCL]].

HCL stands for HashiCorp Configuration Language. It's a declarative language designed to be both human-readable and machine-friendly, used across several HashiCorp tools.
</quiz>

<quiz>
What happens when you run `terraform plan`?

- [ ] It applies changes to your infrastructure immediately
- [ ] It downloads and installs provider plugins
- [x] It compares desired state to current state and shows what changes would be made
- [ ] It validates syntax without checking against real infrastructure

`terraform plan` creates an execution plan by reading the current state, comparing it to your configuration, and proposing the changes needed to reach the desired state — without actually making any changes.
</quiz>

<quiz>
Which of the following files should typically be committed to version control? (Select all that apply)

- [x] main.tf
- [x] variables.tf
- [ ] terraform.tfstate
- [ ] .terraform/ directory
- [x] outputs.tf

The state file (`terraform.tfstate`) contains sensitive data and current infrastructure state — it should not be committed. The `.terraform/` directory contains downloaded providers and is regenerated by `terraform init`. Your `.tf` configuration files should always be version controlled.
</quiz>

<quiz>
You want to store your Terraform state remotely so your team can collaborate. Which block do you configure this in?

- [ ] `provider`
- [ ] `resource`
- [x] `terraform` (backend configuration)
- [ ] `data`

Remote state is configured using a `backend` block nested inside the `terraform` block. Common backends include S3, Azure Blob Storage, GCS, and Terraform Cloud.
</quiz>

<quiz>
The command to remove all resources managed by your Terraform configuration is `terraform [[destroy]]`.

`terraform destroy` is the inverse of `terraform apply` — it terminates all resources defined in your configuration. It shows a plan first and requires confirmation.
</quiz>

<quiz>
What is the difference between `terraform.tfvars` and `variables.tf`?

- [ ] They are interchangeable names for the same thing
- [ ] `terraform.tfvars` defines variable types; `variables.tf` sets values
- [x] `variables.tf` declares variables and their types/defaults; `terraform.tfvars` assigns values to those variables
- [ ] `terraform.tfvars` is for secrets only; `variables.tf` is for everything else

`variables.tf` contains `variable` blocks that declare what variables exist, their types, descriptions, and optional defaults. `terraform.tfvars` is where you assign actual values to those declared variables.
</quiz>

<quiz>
Which of the following are valid ways to provide values for Terraform variables? (Select all that apply)

- [x] `-var` flag on the command line
- [x] `terraform.tfvars` file
- [x] Environment variables prefixed with `TF_VAR_`
- [ ] Inline within `resource` blocks using `set`
- [x] `-var-file` flag pointing to a `.tfvars` file

Terraform supports multiple ways to set variables: CLI flags (`-var`), variable files (`terraform.tfvars` or custom files via `-var-file`), and environment variables (`TF_VAR_name`). Terraform auto-loads `terraform.tfvars` and `*.auto.tfvars` files.
</quiz>

<quiz>
What does Terraform do when a resource in your configuration is removed but still exists in the state file?

- [ ] Ignores it and leaves the real resource untouched
- [ ] Throws an error requiring manual state cleanup
- [x] Plans to destroy the real resource on the next apply
- [ ] Automatically removes it from state without destroying the real resource

Terraform compares configuration to state. If a resource exists in state but not in configuration, Terraform plans to destroy it. If you want to stop managing a resource without destroying it, use `terraform state rm`.
</quiz>

<quiz>
A Terraform provider is best described as:

- [ ] A cloud account or subscription
- [x] A plugin that translates Terraform configuration into API calls for a specific platform
- [ ] A module that groups related resources
- [ ] A backend for storing state files

Providers are plugins that act as a translation layer between Terraform and target APIs. Each provider (AWS, Azure, GCP, etc.) understands how to manage the lifecycle of its resources by making the appropriate API calls.
</quiz>

<quiz>
In Terraform, the expression `aws_instance.web.id` refers to the [[id]] attribute of a resource with type `aws_instance` and name `web`.

Resource attributes are accessed using the pattern `resource_type.resource_name.attribute`. These references create implicit dependencies — Terraform knows to create the referenced resource first.
</quiz>

<quiz>
What is the purpose of `terraform state` subcommands?

- [ ] To modify your `.tf` configuration files
- [ ] To interact with the provider registry
- [x] To perform advanced operations on the state file like moving, removing, or inspecting tracked resources
- [ ] To manage remote backend authentication

`terraform state` subcommands (`list`, `show`, `mv`, `rm`, `pull`, `push`) let you inspect and manipulate the state file directly — useful for refactoring, importing existing resources, or removing resources from management.
</quiz>

<quiz>
Which of the following cause Terraform to create implicit dependencies between resources? (Select all that apply)

- [x] Referencing one resource's attribute in another resource's configuration
- [ ] Placing resources in the same `.tf` file
- [x] Using a resource's output as an input to a `data` source
- [ ] Giving two resources the same provider

Terraform builds a dependency graph by analyzing references. When resource B references an attribute of resource A, Terraform knows A must be created first. File organization and provider assignment don't create dependencies.
</quiz>

<quiz>
You have existing cloud infrastructure that was created manually. The Terraform command to bring it under Terraform management is `terraform [[import]]`.

`terraform import` associates an existing resource with a Terraform resource block in your configuration, adding it to the state file. After importing, you still need to write the corresponding configuration to keep it in sync.
</quiz>

<quiz>
What does the `count` meta-argument do in a resource block?

- [ ] Counts how many times the resource has been modified
- [x] Creates multiple instances of the same resource based on a numeric value
- [ ] Sets a maximum retry count for failed provisioning
- [ ] Limits the number of API calls Terraform makes

`count` lets you create multiple instances of a resource. Each instance is identified by its index (e.g., `aws_instance.server[0]`). For more complex iteration, `for_each` is often preferred as it uses meaningful keys instead of numeric indices.
</quiz>

<quiz>
What is the key difference between `count` and `for_each`?

- [ ] `count` works with modules; `for_each` only works with resources
- [ ] `for_each` is deprecated in favor of `count`
- [x] `count` uses numeric indices; `for_each` uses map or set keys, making it safer for additions/removals
- [ ] `count` creates resources in parallel; `for_each` creates them sequentially

With `count`, removing an item from the middle shifts all indices, potentially forcing recreation of unchanged resources. `for_each` uses stable keys, so adding or removing an item only affects that specific instance.
</quiz>

<quiz>
When Terraform displays a plan, a resource prefixed with `~` means:

- [ ] The resource will be created
- [ ] The resource will be destroyed
- [x] The resource will be updated in-place
- [ ] The resource will be replaced (destroyed then created)

Terraform uses symbols in plan output: `+` for create, `-` for destroy, `~` for update in-place, and `-/+` for destroy and recreate (replacement). The `~` indicates a non-destructive change.
</quiz>

<quiz>
Which of the following statements about Terraform modules are true? (Select all that apply)

- [x] A module is a container for multiple resources that are used together
- [x] Modules can be sourced from the Terraform Registry, Git repos, or local paths
- [ ] Modules cannot accept input variables
- [x] The root module is the set of `.tf` files in the working directory

Every Terraform configuration has at least one module — the root module, which consists of the `.tf` files in your working directory. Child modules can be called from the root and accept input variables via the `module` block.
</quiz>

<quiz>
What happens if two team members run `terraform apply` at the same time against the same state file?

- [ ] Both applies succeed and changes are merged
- [ ] Terraform automatically queues the second apply
- [x] State locking prevents the second apply from proceeding (if the backend supports it)
- [ ] The state file becomes corrupted

Backends like S3 (with DynamoDB), Terraform Cloud, and Azure Blob support state locking. When one operation is in progress, the state is locked and other operations will fail with a lock error until it's released.
</quiz>

<quiz>
The Terraform block attribute `required_providers` is used to:

- [x] Specify which providers the configuration depends on, including version constraints and source addresses
- [ ] Automatically install all available providers
- [ ] Define cloud credentials for each provider
- [ ] List providers that must be removed before applying

`required_providers` inside the `terraform` block declares provider dependencies with source addresses and version constraints (e.g., `~> 5.0`), ensuring consistent provider versions across your team.
</quiz>

<quiz>
A `local` value in Terraform is best described as:

- [ ] A variable that can only be set from the command line
- [ ] A resource that only exists during planning
- [x] A named expression that simplifies repeated or complex expressions within a module
- [ ] A provider-specific configuration setting

`locals` blocks define named values computed from expressions. They reduce repetition and improve readability — like assigning a variable in a programming language. Unlike input variables, locals aren't exposed to module callers.
</quiz>

<quiz>
You want Terraform to ignore changes that external processes make to a specific resource attribute. Which lifecycle argument do you use?

- [ ] `prevent_destroy`
- [ ] `create_before_destroy`
- [x] `ignore_changes`
- [ ] `replace_triggered_by`

The `ignore_changes` lifecycle argument tells Terraform to disregard changes to specified attributes during planning. This is useful when external systems (like autoscaling) modify attributes that you don't want Terraform to revert.
</quiz>
